AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for workflow orchestration with Bedrock Agent Chaining'

Parameters:
  KnowledgeBaseName:
    Type: String
    Default: "policy-docs-kb"
    Description: The name of the amazon Bedrock Knowledge Base.
  KnowledgeBaseDescription:
    Type: String
    Default: "This is the Amazon Bedrock Knowledge Base which holds the insurance policy documents"
    Description: The description of the knowledge base.
  OpenSearchCollectionName:
    Type: String
    Default: "policy-docs-collection"
    Description: The name of the OpenSearch Serverless collection.
  DataSourceName:
    Type: String
    Default: "policy-data-source"
    Description: The name of the data source used while setting up Amazon Bedrock Knowledge Base.
  DataSourceDescription:
    Type: String
    Default: "Data source for Policy Docs in S3"
    Description: The description of the data source.
  IndexName:
    Type: String
    Default: "bedrock-knowledge-base-default-index"
    Description: The name of the index to be created in OpenSearch Serverless.

Resources:
  DamageImagesBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete

  HtmlBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete

  PolicyDocsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete

  DamageAnalysisAgentRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: AmazonBedrockExecutionRoleForAgents_DamageAnalysisAgentRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"
      Policies:
        - PolicyName: BedrockAgentInvokeModelPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: bedrock:InvokeModel
                Resource: !Sub arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-v2:1

  PolicyAgentRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: AmazonBedrockExecutionRoleForAgents_PolicyAgentRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"
      Policies:
        - PolicyName: BedrockAgentInvokeModelPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: bedrock:InvokeModel
                Resource: !Sub arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-v2:1

  InsuranceOrchestratorAgentRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: AmazonBedrockExecutionRoleForAgents_OrchestratorAgent
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*"
      Policies:
        - PolicyName: BedrockAgentInvokeModelPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: bedrock:InvokeModel
                Resource: !Sub arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-v2:1

  DamageAnalysisLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: DamageAnalysisLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub arn:aws:s3:::${DamageImagesBucket}/*
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: !Sub arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-3-sonnet-20240229-v1:0
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"      


  DamageAnalysisLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: DamageAnalysisFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt DamageAnalysisLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import random
          import json
          import base64
          import boto3
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          # Initialize S3 client
          s3_client = boto3.client('s3')
          s3_bucket = os.environ['CLAIMIMAGE_SUBMITTED_BUCKET']
          region = os.environ['AWS_REGION']

          # Bedrock client used to interact with APIs around models
          bedrock = boto3.client(
              service_name='bedrock', 
              region_name = region
          )
              
          # Bedrock Runtime client used to invoke and question the models
          bedrock_runtime = boto3.client(
              service_name='bedrock-runtime', 
              region_name = region
          )


          def lambda_handler(event, context):
              api_path = event['apiPath']
              logger.info('API Path')
              logger.info(api_path)
              logger.info('Lambda Event Request:')
              logger.info(json.dumps(event))
              
              if api_path == '/detect_damage':
                  print(event['requestBody']['content']['application/json']['properties'])
                  data = {
                  "claim_id": "",
                  "image_path": ""
                  }
                  
                  # Extracting damage details from the parsed JSON
                  print(event['requestBody']['content']['application/json']['properties'])
                  for damage_detail in event['requestBody']['content']['application/json']['properties']:
                      if damage_detail['type'] == 'string':
                          data[damage_detail['name']] = damage_detail['value']
                      else:
                          data[damage_detail['name']] = json.loads(damage_detail['value'])
                  claim_id = data['claim_id']           
                  image_path = data['image_path']
                  
                  s3_object_key = image_path
                  s3_response = s3_client.get_object(Bucket=s3_bucket, Key=s3_object_key)
                  s3_data = s3_response['Body'].read()
                  s3_data_base64 = base64.b64encode(s3_data).decode('utf-8')
                  
                  # Construct the JSON body
                  body = json.dumps(
                      {
                          "anthropic_version": "bedrock-2023-05-31",
                          "max_tokens": 1000,
                          "messages": [
                              {
                                  "role": "user",
                                  "content": [
                                      {
                                          "type": "image",
                                          "source": {
                                              "type": "base64",
                                              "media_type": "image/jpeg",
                                              "data": s3_data_base64,
                                          },
                                      },
                                      {"type": "text", "text": "Explain in detail the summary of the damages in this image?"},
                                  ],
                              }
                          ],
                      }
                  )

                  # Invoke the model
                  response = bedrock_runtime.invoke_model(
                      modelId="anthropic.claude-3-sonnet-20240229-v1:0",
                      body=body
                  )
                  
                  # Process the response
                  response_body = json.loads(response.get("body").read())
                  print("Summary of damages:", response_body['content'][0]['text'])
                  
                  # Construct your response
                  body = { "damage_description": response_body['content'][0]['text']}
                  
              else:
                  body = {"message": "{} is not a valid API. Please try another one.".format(api_path)}

              response_body = {
                  'application/json': {
                      'body': json.dumps(body)
                  }
              }
                  
              action_response = {
                  'actionGroup': event['actionGroup'],
                  'apiPath': event['apiPath'],
                  'httpMethod': event['httpMethod'],
                  'httpStatusCode': 200,
                  'responseBody': response_body
              }

              api_response = {
                  'messageVersion': '1.0', 
                  'response': action_response
              }
                  
              return api_response
      Timeout: 600
      Environment:
        Variables:
          CLAIMIMAGE_SUBMITTED_BUCKET: !Ref DamageImagesBucket

  ClaimsAdjustersQueue:
    Type: AWS::SQS::Queue
    Properties:
      VisibilityTimeout: 300

  NotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: NotificationLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource: !GetAtt ClaimsAdjustersQueue.Arn
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"

  NotificationLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: NotificationFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt NotificationLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import boto3
          import os

          # Initialize the SQS client
          sqs_client = boto3.client('sqs')
          queue_url = os.environ['NOTIFICATION_QUEUE_URL']

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def send_to_sqs(message_body):
              # Send message to SQS queue
              sqs_client.send_message(
                  QueueUrl=queue_url,
                  MessageBody=json.dumps(message_body)
              )

          def lambda_handler(event, context):
              api_path = event['apiPath']
              logger.info('API Path')
              logger.info(api_path)
              logger.info('Lambda Event Request:')
              logger.info(json.dumps(event))
              
              if api_path == '/send_notification':
                  
                  data = {
                      "claim_id": "",
                      "damage_description": ""
                  }

                  # Extract data from the event
                  print(event['requestBody']['content']['application/json']['properties'])
                  for summarized_damage_analysis in event['requestBody']['content']['application/json']['properties']:
                      if summarized_damage_analysis['type'] == 'string':
                          data[summarized_damage_analysis['name']] = summarized_damage_analysis['value']
                      else:
                          data[summarized_damage_analysis['name']] = json.loads(summarized_damage_analysis['value'])
                  damage_description = data['damage_description']           
                  claim_id = data['claim_id'] 
              
                  # Send the data to SQS
                  send_to_sqs({'claim_id': claim_id, 'damage_description': damage_description})
                  body = {"status": "Information sent to Claims Adjuster" }
                  
              else:
                  body = {"message": "{} is not a valid API. Please try another one.".format(api_path)}
                  
              response_body = {
                  'application/json': {
                      'body': json.dumps(body)
                  }
              }
                  
              action_response = {
                  'actionGroup': event['actionGroup'],
                  'apiPath': event['apiPath'],
                  'httpMethod': event['httpMethod'],
                  'httpStatusCode': 200,
                  'responseBody': response_body
              }

              api_response = {
                  'messageVersion': '1.0', 
                  'response': action_response
              }
                  
              return api_response
      Timeout: 600
      Environment:
        Variables:
          NOTIFICATION_QUEUE_URL: !Ref ClaimsAdjustersQueue

  DamageAnalysisAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: DamageAnalysisNotificationBedrockAgent
      AgentResourceRoleArn: !Sub "arn:aws:iam::${AWS::AccountId}:role/AmazonBedrockExecutionRoleForAgents_DamageAnalysisAgentRole" 
      AutoPrepare: true
      Instruction: |
        You are a helpful virtual assistant whose goal is to do a preliminary analysis on the images uploaded by users for their insurance claims and send notifications to claims adjusters about your initial analysis.
        Here are the steps you should follow in exact order for preliminary analysis of the images:
        Step 1: Analyze the uploaded images for damages.
        Step 2: Send a notification of the analysis of these damages to the claims adjusters.
      FoundationModel:  anthropic.claude-v2:1
      Description: DamageAnalysis_Agent
      IdleSessionTTLInSeconds: 3600
      ActionGroups:
        - ActionGroupName: DamageAnalysisActionGroup
          Description: The action group for Damage analysis
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "Damage Detection API",
                  "version": "1.0.0",
                  "description": "An API to analyze damages for an uploaded image for a claim"
                },
                "paths": {
                  "/detect_damage": {
                    "post": {
                      "summary": "Detect and Analyze Damage for uploaded images",
                      "description": "Analyze the uploaded images for damages.",
                      "operationId": "detectDamage",
                      "requestBody": {
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "image_path": {
                                  "type": "string",
                                  "description": "Image name for claim",
                                  "minLength": 1
                                },
                                "claim_id": {
                                  "type": "string",
                                  "description": "Identifier for the created claim",
                                  "minLength": 1
                                }
                              },
                              "required": [
                                "image_path",
                                "claim_id"
                              ]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful response",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "damage_description": {
                                    "type": "string",
                                    "description": "Summary description of the detected damages."
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
          ActionGroupState: ENABLED
          ActionGroupExecutor: 
            Lambda: !GetAtt DamageAnalysisLambdaFunction.Arn

        - ActionGroupName: NotificationActionGroup
          Description: The action group for sending notifications
          ApiSchema:
            Payload: |
              {
                  "openapi": "3.0.0",
                  "info": {
                    "title": "Send Notifications Assistant",
                    "version": "1.0.0",
                    "description": "API for sending notification to claims adjuster after a damage analysis of the images has been completed."
                  },
                  "paths": {
                    "/send_notification": {
                      "post": {
                        "summary": "Send notification of summarized damage analysis to Claims Adjusters",
                        "description": "Send a notification of the analysis of the images to the claims adjusters. This API must be called only after analysis of the images for damages is completed.",
                        "operationId": "sendNotification",
                        "requestBody": {
                          "required": true,
                          "content": {
                            "application/json": {
                              "schema": {
                                  "type": "object",
                                  "properties": {
                                      "claim_id": {
                                        "type": "string",
                                        "description": "Identifier for the created claim.",
                                        "minLength": 1
                                        },
                                      "damage_description": {
                                        "type": "string",
                                        "description": "Summary description of the detected damages.",
                                        "minLength": 1
                                      }
                                    },
                                    "required": [
                                      "claim_id",
                                      "damage_description"
                                  ]
                              }
                            }
                          }
                        },
                        "responses": {
                          "200": {
                            "description": "Success",
                            "content": {
                              "application/json": {
                                "schema": {
                                  "type": "object",
                                  "properties": {
                                    "status": {
                                      "type": "string",
                                      "description": "Status of the notification sent to Claims Adjuster"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                }
              } 
          ActionGroupState: ENABLED
          ActionGroupExecutor: 
            Lambda: !GetAtt NotificationLambdaFunction.Arn

  NotificationLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt NotificationLambdaFunction.Arn
      Action: "lambda:InvokeFunction"
      Principal: "bedrock.amazonaws.com"  # Use the correct service principal for the Bedrock agent
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${DamageAnalysisAgent}"

  DamageAnalysisInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt DamageAnalysisLambdaFunction.Arn
      Action: "lambda:InvokeFunction"
      Principal: "bedrock.amazonaws.com"  # Use the correct service principal for the Bedrock agent
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${DamageAnalysisAgent}"

  # Lambda Layer for OpenSearch and AWS4Auth
  CreateIndexLambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: "CreateIndexLambdaLayer"
      Description: "Lambda layer for OpenSearch and AWS4Auth"
      Content: 
        S3Bucket: "aws-blogs-artifacts-public"
        S3Key: "artifacts/ML-16537/lambda-layer-opensearch-python3.10-x86_64.zip"
      CompatibleRuntimes:
        - python3.10

  # Create IAM Role for Bedrock Knowledge Base
  BedrockKnowledgeBaseRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: BedrockKnowledgeBasePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !GetAtt PolicyDocsBucket.Arn
                  - !Sub "${PolicyDocsBucket.Arn}/*"
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                Resource: "*"
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeAgent
                Resource: "*"

  # Create IAM Role for Lambda Function
  CreateIndexLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Permissions for logging
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              # Permissions to interact with OpenSearch Serverless
              - Effect: Allow
                Action:
                  - aoss:*
                Resource: "*"
              # Permissions to retrieve AWS credentials
              # - Effect: Allow
              #   Action:
              #     - sts:AssumeRole
              #   Resource: "*"

  # Lambda Function to Create Index
  CreateIndexLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CreateIndexFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Timeout: 600  # Timeout set for 10 minutes
      Role: !GetAtt CreateIndexLambdaExecutionRole.Arn
      Layers:
        - !Ref CreateIndexLambdaLayer
      Code:
        ZipFile: |
          import boto3
          import time
          from opensearchpy import OpenSearch, RequestsHttpConnection
          from requests_aws4auth import AWS4Auth
          import json
          import os
          import cfnresponse

          def lambda_handler(event, context):
              print(event)
              time.sleep(60)
              region = os.environ['AWS_REGION']
              service = 'aoss'
              credentials = boto3.Session().get_credentials()
              awsauth = AWS4Auth(credentials.access_key, credentials.secret_key, region, service, session_token=credentials.token)

              collection_arn = event['ResourceProperties']['OpenSearchCollectionArn']
              endpoint = f"{collection_arn.split('/')[-1]}.{region}.aoss.amazonaws.com"
              index_name = event['ResourceProperties']['IndexName']

              client = OpenSearch(
                  hosts=[{'host': endpoint, 'port': 443}],
                  http_auth=awsauth,
                  use_ssl=True,
                  verify_certs=True,
                  connection_class=RequestsHttpConnection
              )

              try:
                  if event['RequestType'] == 'Delete':
                      client.indices.delete(index=index_name)
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  # Assume Create for simplicity
                  index_body = {
                      "settings": {
                          "index": {
                            "knn" : "true"
                          }
                      },
                      "mappings": {
                          "properties": {
                              "bedrock-knowledge-base-default-vector": {
                                  "type": "knn_vector",
                                  "dimension": 1024,
                                  "method": {
                                      "engine": "faiss",
                                      "name": "hnsw",
                                      "space_type": "l2",
                                      "parameters": {}
                                  }
                              },
                              "AMAZON_BEDROCK_METADATA": {
                                    "type": "text",
                                    "index": "false"
                              },
                              "AMAZON_BEDROCK_TEXT_CHUNK": {
                                    "type": "text"
                              },
                              "id": {
                                    "type": "text",
                                    "fields": {
                                        "keyword": {
                                            "type": "keyword",
                                            "ignore_above": 256
                                        }
                                    }
                              },
                              "policynumber": {
                                "type": "text",
                                "fields": {
                                  "keyword": {
                                    "type": "keyword",
                                    "ignore_above": 256
                                  }
                                }
                              },
                              "type": {
                                "type": "text",
                                "fields": {
                                  "keyword": {
                                    "type": "keyword",
                                    "ignore_above": 256
                                  }
                                }
                              },
                              "x-amz-bedrock-kb-source-uri": {
                                "type": "text",
                                "fields": {
                                  "keyword": {
                                    "type": "keyword",
                                    "ignore_above": 256
                                  }
                                }
                              }
                          }
                      }
                  }
                  response = client.indices.create(index=index_name, body=index_body)
                  time.sleep(60)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Response': response})
              except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})
  CreateIndexCustomResource:
    Type: Custom::CreateIndex
    Properties:
      ServiceToken: !GetAtt CreateIndexLambdaFunction.Arn
      OpenSearchCollectionArn: !GetAtt OpenSearchServerlessCollection.Arn
      IndexName: !Ref IndexName
    DependsOn: 
      - OpenSearchServerlessCollection
      - OpenSearchServerlessEncryptionPolicy
      - OpenSearchServerlessNetworkPolicy
      - OpenSearchServerlessDataAccessPolicy

  # Create OpenSearch Serverless Security Policy for Encryption
  OpenSearchServerlessEncryptionPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: "agents-encryption-policy"
      Type: "encryption"
      Description: "Encryption policy for Bedrock Knowledge Base"
      Policy:
        Fn::Sub: |
          {
            "Rules": [
              {
                "ResourceType": "collection",
                "Resource": ["collection/${OpenSearchCollectionName}"]
              }
            ],
            "AWSOwnedKey": true
          }

  # Create OpenSearch Serverless Security Policy for Network
  OpenSearchServerlessNetworkPolicy:
    Type: AWS::OpenSearchServerless::SecurityPolicy
    Properties:
      Name: "agents-network-policy"
      Type: "network"
      Description: "Network policy for Bedrock Knowledge Base"
      Policy:
        Fn::Sub: |
          [{
            "Rules": [
              {
                "ResourceType": "collection",
                "Resource": ["collection/${OpenSearchCollectionName}"]
              },
              {
                "ResourceType": "dashboard",
                "Resource": ["collection/${OpenSearchCollectionName}"]
              }
            ],
            "AllowFromPublic": true
          }]

  # Create OpenSearch Serverless Data Access Policy
  OpenSearchServerlessDataAccessPolicy:
    Type: AWS::OpenSearchServerless::AccessPolicy
    Properties:
      Name: "agents-data-policy"
      Type: "data"
      Description: "Data access policy for Bedrock Knowledge Base"
      Policy:
        Fn::Sub: |
          [{
            "Description": "Access for Bedrock Knowledge Base",
            "Rules": [
              {
                "ResourceType": "index",
                "Resource": ["index/*/*"],
                "Permission": ["aoss:*"]
              },
              {
                "ResourceType": "collection",
                "Resource": ["collection/${OpenSearchCollectionName}"],
                "Permission": ["aoss:*"]
              }
            ],
            "Principal": ["${BedrockKnowledgeBaseRole.Arn}", "${CreateIndexLambdaExecutionRole.Arn}"]
          }]

  # Create OpenSearch Serverless Collection
  OpenSearchServerlessCollection:
    Type: AWS::OpenSearchServerless::Collection
    Properties:
      Name: !Ref OpenSearchCollectionName
      Type: "VECTORSEARCH"
      Description: "Collection for Bedrock Knowledge Base"
    DependsOn: OpenSearchServerlessEncryptionPolicy

  # Bedrock Knowledge Base
  BedrockKnowledgeBase:
    Type: AWS::Bedrock::KnowledgeBase
    DependsOn: CreateIndexCustomResource
    Properties:
      Name: !Ref KnowledgeBaseName
      Description: !Ref KnowledgeBaseDescription
      RoleArn: !GetAtt BedrockKnowledgeBaseRole.Arn
      KnowledgeBaseConfiguration:
        Type: "VECTOR"
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub "arn:${AWS::Partition}:bedrock:${AWS::Region}::foundation-model/cohere.embed-english-v3"
      StorageConfiguration:
        Type: "OPENSEARCH_SERVERLESS"
        OpensearchServerlessConfiguration:
          CollectionArn: !GetAtt OpenSearchServerlessCollection.Arn
          VectorIndexName: !Ref IndexName
          FieldMapping:
            VectorField: "bedrock-knowledge-base-default-vector"
            TextField: "AMAZON_BEDROCK_TEXT_CHUNK"
            MetadataField: "AMAZON_BEDROCK_METADATA"

  SampleDataSource:
    Type: AWS::Bedrock::DataSource
    Properties:
      KnowledgeBaseId: !Ref BedrockKnowledgeBase
      Name: !Ref DataSourceName
      Description: !Ref DataSourceDescription
      DataSourceConfiguration:
        Type: "S3"
        S3Configuration:
          BucketArn: !GetAtt PolicyDocsBucket.Arn

  # Lambda Layer for OpenSearch and AWS4Auth
  CreateBoto3LambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: "CreateBoto3LambdaLayer"
      Description: "Lambda layer for boto3 for using metadat data in Knowledge bases"
      Content: 
        S3Bucket: "aws-blogs-artifacts-public"
        S3Key: "artifacts/ML-16537/bedrock-layer.zip"
      CompatibleRuntimes:
        - python3.10

  PolicyRetrievalLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: PolicyRetrievalLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                Resource: "*"

  PolicyRetrievalLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PolicyRetrievalFunction
      Layers:
        - !Ref CreateBoto3LambdaLayer
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt PolicyRetrievalLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import random
          import string
          import boto3
          import uuid
          import time
          import pprint
          import json
          import botocore
          import os

          #This was initially being invoked by Bedrock agent
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Initialize the Bedrock agent runtime client
          config = botocore.config.Config(
              read_timeout=900,
              connect_timeout=900,
              retries={"max_attempts": 0}
          )
          # Initialize the Bedrock agent runtime client
          bedrock_agent_runtime_client = boto3.client('bedrock-agent-runtime',config=config)

          model_id = "anthropic.claude-v2:1" 
          region_id = os.environ['REGION'] 
          kb_id = os.environ['KB_ID'] # replace it with the Knowledge base id.

          def retrieveAndGenerate(question, policytype, policynumber, kbId, modelId, regionId, sessionId = None):
              model_arn = f'arn:aws:bedrock:{regionId}::foundation-model/{modelId}'
              if sessionId:
                  return bedrock_agent_runtime_client.retrieve_and_generate(
                      input={
                          'text': question
                      },
                      retrieveAndGenerateConfiguration={
                          'type': 'KNOWLEDGE_BASE',
                          'knowledgeBaseConfiguration': {
                              'knowledgeBaseId': kbId,
                              'modelArn': model_arn,
                              'retrievalConfiguration': {
                                  'vectorSearchConfiguration': {
                                      'filter': {
                                          "andAll": [
                                              {
                                                  "equals": {
                                                      "key": "type",
                                                      "value": policytype
                                                  }
                                              },
                                              {
                                                  "startsWith": {
                                                      "key": "policynumber",
                                                      "value": policynumber
                                                  }
                                              }
                                          ]
                                      },
                                      'numberOfResults': 10,  # Assuming a number of results
                                  }
                              }
                          }
                      },
                      sessionId=sessionId
                  )
              else:
                  return bedrock_agent_runtime_client.retrieve_and_generate(
                      input={
                          'text': question
                      },
                      retrieveAndGenerateConfiguration={
                          'type': 'KNOWLEDGE_BASE',
                          'knowledgeBaseConfiguration': {
                              'knowledgeBaseId': kbId,
                              'modelArn': model_arn,
                              'retrievalConfiguration': {
                                  'vectorSearchConfiguration': {
                                      'filter': {
                                          "andAll": [
                                              {
                                                  "equals": {
                                                      "key": "type",
                                                      "value": policytype
                                                  }
                                              },
                                              {
                                                  "startsWith": {
                                                      "key": "policynumber",
                                                      "value": policynumber
                                                  }
                                              }
                                          ]
                                      },
                                      'numberOfResults': 10,  # Assuming a number of results
                                  }
                              }
                          }
                      }
                  )

          def lambda_handler(event, context):
              logger.info('Lambda Event Request:')
              logger.info(json.dumps(event))
              logger.info(context)
              result = ''
              response_code = 200
              action_group = event['actionGroup']
              api_path = event['apiPath']
              http_method = event['httpMethod']
              # sessionId =  event['sessionId'] #this will be used by BA2's context
              
              
              if api_path == '/retrievePolicyDetails':
                  data = {
                  "question":"",
                  "policytype": "",
                  "policynumber": ""
                  }
                  # Extracting claim details from the parsed JSON
                  logger.info(event['requestBody']['content']['application/json']['properties'])
                  for policy_details in event['requestBody']['content']['application/json']['properties']:
                      if policy_details['type'] == 'string':
                          data[policy_details['name']] = policy_details['value']
                      else:
                          data[policy_details['name']] = json.loads(policy_details['value'])
                  policytype = data['policytype']           
                  policynumber = data['policynumber']
                  question = data['question']

                  
                  
                  try:
                      response = retrieveAndGenerate(question,policytype,policynumber,kb_id,model_id,region_id)
                      generated_text = response['output']['text']
                      logger.info(generated_text)
                      citations = response["citations"]
                      contexts = []
                      for citation in citations:
                          retrievedReferences = citation["retrievedReferences"]
                          for reference in retrievedReferences:
                              contexts.append(reference["content"]["text"])
                      logger.info(contexts)
                  except Exception as e:
                      logger.error("An error occurred: {}".format(str(e)))
                      generated_text = None
                      contexts = None
                          
                  body = {
                      "results": generated_text,
                      "contexts": contexts
                  }
                  
              else:
                  response_code = 404
                  result = f"Unrecognized api path: {action_group}::{api_path}"
                  
              response_body = {
                  'application/json': {
                      'body': json.dumps(body)
                  }
              }
                  
              action_response = {
                  'actionGroup': action_group,
                  'apiPath': api_path,
                  'httpMethod': http_method,
                  'httpStatusCode': response_code,
                  'responseBody': response_body
              }

              api_response = {'messageVersion': '1.0', 'response': action_response}
              return api_response
      Timeout: 600
      Environment:
        Variables:
          KB_ID: !Ref BedrockKnowledgeBase
          REGION: !Ref AWS::Region

  PolicyAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: PolicyBedrockAgent
      AutoPrepare: true
      AgentResourceRoleArn: !Sub "arn:aws:iam::${AWS::AccountId}:role/AmazonBedrockExecutionRoleForAgents_PolicyAgentRole"
      Instruction: You are a knowledgeable and helpful virtual assistant for insurance policy questions.
      FoundationModel: anthropic.claude-v2:1
      Description: PolicyAnalysis_Agent
      IdleSessionTTLInSeconds: 3600
      ActionGroups:
        - ActionGroupName: PolicyBedrockAgentActionGroup
          Description: Insurance policy retrieval action
          ApiSchema:
            Payload: |
              {
                  "openapi": "3.0.0",
                  "info": {
                    "title": "Insurance Policy Information API",
                    "version": "1.0.0",
                    "description": "Answers questions related to insurance policies issues based on the policy type and policy number"
                  },
                  "paths": {
                    "/retrievePolicyDetails": {
                      "post": {
                        "summary": "Answers questions related to insurance policies issues based on the policy type and policy number",
                        "description": "Answers questions related to insurance policies issues based on the policy type and policy number",
                        "operationId": "retrievePolicyDetails",
                        "requestBody": {
                          "required": true,
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "question": 
                                  {
                                    "type": "string",
                                    "description": "Question that needs answers",
                                    "minLength": 1
                                  },
                                  "policytype":
                                  {
                                    "type": "string",
                                    "description": "Policy Type  of the Insurance Policy. Only Valid Values are Life and Auto.",
                                    "minLength": 1
                                  },
                                  "policynumber": {
                                    "type": "string",
                                    "description": "Policy Number of the Insurance Policy." ,
                                    "minLength": 1
                                  }
                                },
                                "required": [
                                  "question",
                                  "policytype",
                                  "policynumber"
                                ]
                              }
                            }
                          }
                        },
                        "responses": {
                          "200": {
                            "description": "Successful response",
                            "content": {
                              "application/json": {
                                "schema": {
                                  "type": "object",
                                  "properties": {
                                    "results": {
                                      "type": "string",
                                      "description": "Response to the question asked."
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }  
          ActionGroupState: ENABLED
          ActionGroupExecutor: 
            Lambda: !GetAtt PolicyRetrievalLambdaFunction.Arn

  PolicyRetrievalInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PolicyRetrievalLambdaFunction.Arn
      Action: "lambda:InvokeFunction"
      Principal: "bedrock.amazonaws.com"  # Use the correct service principal for the Bedrock agent
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${PolicyAgent}"

  InvokeDamageAgentLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeDamageAgentLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - bedrock:InvokeAgent
                Resource: 
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/${DamageAnalysisAgent}/TSTALIASID"

  InvokeDamageAgentLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: InvokeDamageAgentFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt InvokeDamageAgentLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import random
          import string
          import boto3
          import uuid
          import time
          import pprint
          import json
          import botocore
          import os

          #This was initially being invoked by Bedrock agent
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          # Initialize the Bedrock agent runtime client
          config = botocore.config.Config(
              read_timeout=900,
              connect_timeout=900,
              retries={"max_attempts": 0}
          )

          # Initialize the Bedrock agent runtime client
          bedrock_agent_runtime_client = boto3.client('bedrock-agent-runtime',config=config)


          def lambda_handler(event, context):
              logger.info('Lambda Event Request:')
              logger.info(json.dumps(event))
              logger.info(context)
              result = ''
              response_code = 200
              action_group = event['actionGroup']
              api_path = event['apiPath']
              http_method = event['httpMethod']
              print("api_path: ", api_path )
              
              # Agent Alias Id of the DamageAnalysis_Agent
              agent_id = os.environ['DamageAnalysis_Agent_ID']
              agent_alias_id = 'TSTALIASID'
              
              enable_trace = False
              end_session = False
              
              if api_path == '/invokeDamageAnalysisAgent':
                  data = {
                  "claim_id":"",
                  "image_path": ""
                  }
                  
                  # Extracting details from the parsed JSON
                  print(event['requestBody']['content']['application/json']['properties'])
                  for damage_request in event['requestBody']['content']['application/json']['properties']:
                      if damage_request['type'] == 'string':
                          data[damage_request['name']] = damage_request['value']
                      else:
                          data[damage_request['name']] = json.loads(damage_request['value'])
                  
                  claim_id = data['claim_id']           
                  image_path = data['image_path']
                
                  # At this point we have all the data needed to call DamageAnalysis_Agent 
                  # Define your additional session attributes if needed
                  promptSessionAttributes = { 
                      "claim_id": claim_id,
                      "image_path": image_path
                  }
                  
                  request_body = {
                      "inputText": json.dumps({
                          "parameters": {
                              "claim_id": claim_id, # These will be sent to the action group. 
                              "image_path": image_path
                          }
                      }),
                      "agentId": agent_id,
                      "agentAliasId": agent_alias_id,
                      "sessionId": event['sessionId'], #this will be used by BA2's context
                      "enableTrace": enable_trace,
                      "endSession": end_session,
                      "sessionState": {
                          "promptSessionAttributes": promptSessionAttributes
                      }
                  } 
                  
                  try:
                      # Invoke the agent API
                      print(f"Invoking DamageAnalysis_Agent for Session:: {event['sessionId']}...................")
                      print(request_body)
                      agent_response = bedrock_agent_runtime_client.invoke_agent(**request_body)
                      # print("agent_response ::::.......")
                      # logger.info(pprint.pprint(agent_response))
              
                      # Process the response
                      event_stream = agent_response['completion']
                      for event in event_stream:
                          if 'chunk' in event:
                              print("in chunk....")
                              data = event['chunk']['bytes']
                              logger.info(f"Final answer ->\n{data.decode('utf8')}")
                              agent_answer = data.decode('utf8')
                              end_event_received = True
                          elif 'trace' in event:
                              print("in trace...")
                              logger.info(json.dumps(event['trace'], indent=2))
                          else:
                              raise Exception("Unexpected event.", event)
                  except Exception as e:
                      logger.error("An error occurred: {}".format(str(e)))
                          
                  body = {
                      "status": agent_answer
                  }
                  
              else:
                  response_code = 404
                  result = f"Unrecognized api path: {action_group}::{api_path}"
                  
              response_body = {
                  'application/json': {
                      'body': json.dumps(body)
                  }
              }
                  
              action_response = {
                  'actionGroup': action_group,
                  'apiPath': api_path,
                  'httpMethod': http_method,
                  'httpStatusCode': response_code,
                  'responseBody': response_body
              }

              api_response = {'messageVersion': '1.0', 'response': action_response}
              return api_response
      Timeout: 600
      Environment:
        Variables:
          DamageAnalysis_Agent_ID: !GetAtt DamageAnalysisAgent.AgentId

  InvokePolicyAgentLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokePolicyAgentLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - bedrock:InvokeAgent
                Resource: 
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/${PolicyAgent}/TSTALIASID"

  InvokePolicyAgentLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: InvokePolicyAgentFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt InvokePolicyAgentLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import random
          import string
          import boto3
          import uuid
          import time
          import pprint
          import json
          import botocore
          import os

          #This was initially being invoked by Bedrock agent
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Initialize the Bedrock agent runtime client
          config = botocore.config.Config(
              read_timeout=900,
              connect_timeout=900,
              retries={"max_attempts": 0}
          )
          # Initialize the Bedrock agent runtime client
          bedrock_agent_runtime_client = boto3.client('bedrock-agent-runtime',config=config)


          def lambda_handler(event, context):
              logger.info('Lambda Event Request:')
              logger.info(json.dumps(event))
              logger.info(context)
              result = ''
              response_code = 200
              action_group = event['actionGroup']
              api_path = event['apiPath']
              http_method = event['httpMethod']
              print("api_path: ", api_path )
              
              # Extract the agentAliasId from the response
              agent_id = os.environ['Policy_Agent_ID']
              agent_alias_id = 'TSTALIASID'
              
              enable_trace = False
              end_session = False
              
              if api_path == '/invokePolicyInformationAgent':
                  data = {
                      "user_info":""
                  }
                  
                  # Extracting the conversation/question input by the end user from the parsed JSON
                  print(event['requestBody']['content']['application/json']['properties'])
                  for info in event['requestBody']['content']['application/json']['properties']:
                      if info['type'] == 'string':
                          data[info['name']] = info['value']
                      else:
                          data[info['name']] = json.loads(info['value'])
                          
                  user_info = data['user_info']           

                  request_body = {
                      "inputText": user_info,
                      "agentId": agent_id,
                      "agentAliasId": agent_alias_id,
                      "sessionId": event['sessionId'], #this will be used by BA2's context
                      "enableTrace": enable_trace,
                      "endSession": end_session
                  } #end of requestbody sent to BA2
                  
                  try:
                      # Invoke the agent API
                      print(f"Invoking The Policy Info Agent for Session:: {event['sessionId']}...................")
                      print(request_body)
                      agent_response = bedrock_agent_runtime_client.invoke_agent(**request_body)
              
                      logger.info(pprint.pprint(agent_response))
              
                      # Process the response
                      event_stream = agent_response['completion']
                      for event in event_stream:
                          if 'chunk' in event:
                              print("in chunk....")
                              data = event['chunk']['bytes']
                              logger.info(f"Final answer ->\n{data.decode('utf8')}")
                              agent_answer = data.decode('utf8')
                              end_event_received = True
                          elif 'trace' in event:
                              print("in trace...")
                              logger.info(json.dumps(event['trace'], indent=2))
                          else:
                              raise Exception("Unexpected event.", event)
                  except Exception as e:
                      logger.error("An error occurred: {}".format(str(e)))
                          
                  body = {
                      "results": agent_answer
                  }
                  
              else:
                  response_code = 404
                  result = f"Unrecognized api path: {action_group}::{api_path}"
                  
              response_body = {
                  'application/json': {
                      'body': json.dumps(body)
                  }
              }
                  
              action_response = {
                  'actionGroup': action_group,
                  'apiPath': api_path,
                  'httpMethod': http_method,
                  'httpStatusCode': response_code,
                  'responseBody': response_body
              }

              api_response = {'messageVersion': '1.0', 'response': action_response}
              return api_response
      Timeout: 600
      Environment:
        Variables:
          Policy_Agent_ID: !Ref PolicyAgent

  CreateClaimsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CreateClaimsLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"

  CreateClaimsLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CreateClaimsFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt CreateClaimsLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import random
          import string
          import boto3
          import uuid
          import time
          import pprint
          import json
          import botocore

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Function to detect fraud
          def detect_fraud(description):
              # Placeholder for fraud detection logic
              # Here, we randomly decide whether fraud is detected or not
              is_fraud = random.choice([False, False])
              if is_fraud:
                  logger.info("Fraudulent claim detected.")
              else:
                  logger.info("No fraud detected.")
              return is_fraud
              
          # Function to create a new insurance claim
          def create_claim(customer_name, city, zip_code, state, street_address, claim_type, description):

              # Placeholder for claim creation logic
              # This is where you would insert the claim details into the database
              claim_id = 'CLM' + str(random.randint(10000, 99999))  # Generating a random claim ID as an example
              
              # Assuming an agent will contact the customer within 24 hours
              acknowledgment_message = "Your new claim (ID: {}) has been created. An agent will contact you within 24 hours. We assure you that you will be taken care of.".format(claim_id)
              
              # Return the response object with claimId and status
              return {"claimId": claim_id, "status": acknowledgment_message}



          def lambda_handler(event, context):
              # create_claim
              # detect_fraud

              
              api_path = event['apiPath']
              logger.info('API Path')
              logger.info(api_path)
              logger.info('Lambda Event Request:')
              logger.info(json.dumps(event))
              
              if api_path == '/create_claim':
                  # Parse the JSON string stored in the requestBody field of the event
                  
                  data = {
                  "zipCode": "",
                  "description": "",
                  "customerName": "",
                  "streetAddress": "",
                  "claimType" : "",
                  "state": "",
                  "city":""
                  }
                  # Extracting claim details from the parsed JSON
                  print(event['requestBody']['content']['application/json']['properties'])
                  for claim_request in event['requestBody']['content']['application/json']['properties']:
                      if claim_request['type'] == 'string':
                          data[claim_request['name']] = claim_request['value']
                      else:
                          data[claim_request['name']] = json.loads(claim_request['value'])
                  customer_name = data['customerName']           
                  zip_code = data['zipCode']
                  state = data['state']
                  street_address = data['streetAddress']
                  claim_type = data['claimType']
                  description = data['description']
                  city = data['city']
                  
                  # Create the claim
                  body = create_claim(customer_name, city, zip_code, state, street_address, claim_type, description)

              elif api_path == '/detect_fraud':
                      print(event['requestBody']['content']['application/json']['properties'])
                      # Placeholder for fraud detection logic
                      # For now, returning a random boolean value, but you get the idea.
                      data = {
                          "zipCode": "",
                          "description": "",
                          "customerName": "",
                          "streetAddress": "",
                          "claimType" : "",
                          "state": "",
                          "city":""
                      }
                      # Extracting claim details from the parsed JSON
                      print(event['requestBody']['content']['application/json']['properties'])
                      for claim_request in event['requestBody']['content']['application/json']['properties']:
                          if claim_request['type'] == 'string':
                              data[claim_request['name']] = claim_request['value']
                          else:
                              data[claim_request['name']] = json.loads(claim_request['value'])
                      customer_name = data['customerName']           
                      zip_code = data['zipCode']
                      state = data['state']
                      street_address = data['streetAddress']
                      claim_type = data['claimType']
                      description = data['description']
                      city = data['city']
                      is_fraud = detect_fraud(claim_request)
                      body = {"isFraud": is_fraud , "zipCode":zip_code,"customerName":customer_name,
                              "state":zip_code,"streetAddress": street_address,"claimType":claim_type,
                              "description":description}
              else:
                  body = {"message": "{} is not a valid API. Please try another one.".format(api_path)}
              
              response_body = {
                  'application/json': {
                      'body': json.dumps(body)
                  }
              }

              action_response = {
                  'actionGroup': event['actionGroup'],
                  'apiPath': event['apiPath'],
                  'httpMethod': event['httpMethod'],
                  'httpStatusCode': 200,
                  'responseBody': response_body
              }

              api_response = {
                  'messageVersion': '1.0', 
                  'response': action_response
              }
              
              return api_response
      Timeout: 600

  InsuranceOrchestratorAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: InsuranceOrchestratorBedrockAgent
      AutoPrepare: true
      AgentResourceRoleArn: !Sub "arn:aws:iam::${AWS::AccountId}:role/AmazonBedrockExecutionRoleForAgents_OrchestratorAgent"
      Instruction: |
        You are a helpful virtual assistant whose goal is to provide courteous and human-like responses while helping customers file insurance claims, detect fraud before filing claims, assess damages, and to answer questions related to the customers insurance policy.
      FoundationModel: anthropic.claude-v2:1
      Description: InsuranceOrchestrator_Agent
      IdleSessionTTLInSeconds: 3600
      ActionGroups:
        - ActionGroupName: InvokeDamageAgentActionGroup
          Description: Action to Invoke Damage Analysis Agent
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "Invoke Damage Analysis Agent API",
                  "version": "1.0.0",
                  "description": "An API to delegate to  the Damage Detection Bedrock Agent to analyze damages for an uploaded image"
                },
                "paths": {
                  "/invokeDamageAnalysisAgent": {
                    "post": {
                      "summary": "Detect Damage",
                      "description": "Detect the Damage as part of Evidence Collection if new claim is created",
                      "operationId": "invokeDamageAnalysisAgent",
                      "requestBody": {
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "image_path": {
                                  "type": "string",
                                  "description": "Image name for claim",
                                    "minLength": 1
                                },
                                "claim_id": {
                                  "type": "string",
                                  "description": "Identifier for the created claim",
                                    "minLength": 1
                                }
                              },
                              "required": [
                                "image_path",
                                "claim_id"
                              ]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful response",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "status": {
                                    "type": "string",
                                    "description": "Status of the response."
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
          ActionGroupState: ENABLED
          ActionGroupExecutor: 
            Lambda: !GetAtt InvokeDamageAgentLambdaFunction.Arn
        - ActionGroupName: InvokePolicyAgentActionGroup
          Description: Action to Invoke Policy Analysis Agent
          ApiSchema:
            Payload: |
              {
                  "openapi": "3.0.0",
                  "info": {
                    "title": "Insurance Policy Information API",
                    "version": "1.0.0",
                    "description": "Answers questions related to insurance policies"
                  },
                  "paths": {
                    "/invokePolicyInformationAgent": {
                      "post": {
                        "summary": "Answers questions related to insurance policies",
                        "description": "Answers questions related to insurance policies",
                        "operationId": "invokePolicyInformationAgent",
                        "requestBody": {
                          "required": true,
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "user_info": 
                                  {
                                    "type": "string",
                                    "description": "Question that needs answers",
                                    "minLength": 1
                                  }
                                },
                                "required": [
                                  "user_info"
                                ]
                              }
                            }
                          }
                        },
                        "responses": {
                          "200": {
                            "description": "Successful response",
                            "content": {
                              "application/json": {
                                "schema": {
                                  "type": "object",
                                  "properties": {
                                    "results": {
                                      "type": "string",
                                      "description": "Response to the question asked."
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } 
          ActionGroupState: ENABLED
          ActionGroupExecutor: 
            Lambda: !GetAtt InvokePolicyAgentLambdaFunction.Arn
        - ActionGroupName: ClaimCreationFraudDetectionActionGroup
          Description: Action to Create Claims, Detect Frauds
          ApiSchema:
            Payload: |
              {
                  "openapi": "3.0.0",
                  "info": {
                    "title": "Claims creating Assistant",
                    "version": "1.0.0",
                    "description": "APIs for managing insurance claims by creating new claims and detecting fraud before creating a claim"
                  },
                  "paths": {
                    "/create_claim": {
                      "post": {
                        "summary": "Create New Claim(s)",
                        "description": "Create new claim(s) by requesting information from the customer like name, street address, city, state, zipcode, claim type and description of the incident for which the claim is being created. This API must be called for each new claim creation request, provided the detectFraud determines that this is not a fraud request",
                        "operationId": "createClaim",
                        "requestBody": {
                          "required": true,
                          "content": {
                            "application/json": {
                              "schema": {
                                  "type": "object",
                                  "properties": {
                                      "customerName": {
                                        "type": "string",
                                        "description": "Customer's Name for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "streetAddress": {
                                        "type": "string",
                                        "description": "Customer's Street address for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "city": {
                                        "type": "string",
                                        "description": "Customer's City for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "state": {
                                        "type": "string",
                                        "description": "Customer's State for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "zipCode": {
                                        "type": "string",
                                        "description": "Customer's Zip code for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "claimType": {
                                        "type": "string",
                                        "description": "Type of insurance claim(s)",
                                        "minLength": 1
                                      },
                                      "description": {
                                        "type": "string",
                                        "description": "Brief description of the incident describing the claim(s)",
                                        "minLength": 1
                                      }
                                    },
                                    "required": [
                                      "customerName",
                                      "streetAddress",
                                      "city",
                                      "state",
                                      "zipCode",                
                                      "claimType",
                                      "description"
                                  ]
                              }
                            }
                          }
                        },
                        "responses": {
                          "200": {
                            "description": "Success",
                            "content": {
                              "application/json": {
                                "schema": {
                                  "type": "object",
                                  "properties": {
                                    "claimId": {
                                      "type": "string",
                                      "description": "Identifier for the created claim(s)"
                                    },
                                    "status": {
                                      "type": "string",
                                      "description": "Status of the claim(s) creation process"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "/detect_fraud": {
                      "post": {
                          "summary": "Detect fraud claim(s)",
                          "description": "Detect if the claim(s) are fraud claim(s). This API should be called for every new claim that is being created. This API should be invoked before the claim is actually created.",
                          "operationId": "detectFraud",
                          "requestBody": {
                              "required": true,
                              "content": {
                                  "application/json": {
                                    "schema": {
                                        "type": "object",
                                        "properties": {
                                            "customerName": {
                                        "type": "string",
                                        "description": "Customer's Name for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "streetAddress": {
                                        "type": "string",
                                        "description": "Customer's Street address for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "city": {
                                        "type": "string",
                                        "description": "Customer's City for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "state": {
                                        "type": "string",
                                        "description": "Customer's State for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "zipCode": {
                                        "type": "string",
                                        "description": "Customer's Zip code for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "claimType": {
                                        "type": "string",
                                        "description": "Type of insurance claim(s)",
                                        "minLength": 1
                                      },
                                      "description": {
                                        "type": "string",
                                        "description": "Brief description of the incident describing the claim(s)",
                                        "minLength": 1
                                      }

                                          },
                                          "required": [
                                            "customerName",
                                            "streetAddress",
                                            "city",
                                            "state",
                                            "zipCode",                
                                            "claimType",
                                            "description"
                                        ]
                                    }
                                  }
                              }
                          },
                          "responses": {
                              "200": {
                                  "description": "Success",
                                  "content": {
                                      "application/json": {
                                          "schema": {
                                            "type": "object",
                                            "properties": {
                                                "isFraud": {
                                                    "type": "boolean",
                                                    "description": "Indicator of whether the claim(s) is flagged as fraudulent"
                                                },
                                                "customerName": {
                                        "type": "string",
                                        "description": "Customer's Name for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "streetAddress": {
                                        "type": "string",
                                        "description": "Customer's Street address for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "city": {
                                        "type": "string",
                                        "description": "Customer's City for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "state": {
                                        "type": "string",
                                        "description": "Customer's State for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "zipCode": {
                                        "type": "string",
                                        "description": "Customer's Zip code for creating the claim(s)",
                                        "minLength": 1
                                      },
                                      "claimType": {
                                        "type": "string",
                                        "description": "Type of insurance claim(s)",
                                        "minLength": 1
                                      },
                                        "description": {
                                          "type": "string",
                                          "description": "Brief description of the incident describing the claim(s)",
                                          "minLength": 1
                                        }

                                            }
                                          }
                                      }
                                  }
                              }
                          }
                      }
                  }
                }
              }
  
          ActionGroupState: ENABLED
          ActionGroupExecutor: 
            Lambda: !GetAtt CreateClaimsLambdaFunction.Arn
  
  CreateClaimsInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt CreateClaimsLambdaFunction.Arn
      Action: "lambda:InvokeFunction"
      Principal: "bedrock.amazonaws.com"  # Use the correct service principal for the Bedrock agent
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${InsuranceOrchestratorAgent}"

  InvokePolicyAgentInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt InvokePolicyAgentLambdaFunction.Arn
      Action: "lambda:InvokeFunction"
      Principal: "bedrock.amazonaws.com"  # Use the correct service principal for the Bedrock agent
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${InsuranceOrchestratorAgent}"

  InvokeDamageAgentInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt InvokeDamageAgentLambdaFunction.Arn
      Action: "lambda:InvokeFunction"
      Principal: "bedrock.amazonaws.com"  # Use the correct service principal for the Bedrock agent
      SourceArn: !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${InsuranceOrchestratorAgent}"
 
  ApiForInsureAssistAgentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ApiForInsureAssistAgentPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - "bedrock:InvokeAgent"
                Resource: 
                  - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/${InsuranceOrchestratorAgent}/TSTALIASID"
              - Effect: Allow
                Action:
                  - "execute-api:ManageConnections"
                Resource:
                  - !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/production/POST/@connections/*"


  ApiForInsureAssistAgentLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ApiForInsureAssistAgentFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt ApiForInsureAssistAgentRole.Arn
      Code:
        ZipFile: |
          import boto3
          import uuid
          import logging
          import json
          import botocore
          import os

          # Set up logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Initialize the Bedrock agent runtime client with custom configuration
          config = botocore.config.Config(
              read_timeout=900,
              connect_timeout=900,
              retries={"max_attempts": 0}
          )
          bedrock_agent_runtime_client = boto3.client('bedrock-agent-runtime', config=config)

          def lambda_handler(event, context):
              route_key = event['requestContext']['routeKey']
              connection_id = event['requestContext']['connectionId']
              domain_name = event['requestContext']['domainName']
              stage = event['requestContext']['stage']
              endpoint = f"https://{domain_name}/{stage}/"
              insureassist_agentid = os.environ['INSUREASSIST_AGENTID']

              # Initialize the API Gateway Management Client once for this invocation
              apig_management_client = boto3.client('apigatewaymanagementapi', endpoint_url=endpoint)
              
              if route_key == '$connect':
                  return {'statusCode': 200, 'body': 'Connected'}
              
              elif route_key == '$disconnect':
                  return {'statusCode': 200, 'body': 'Disconnected'}
              
              elif route_key == 'sendmessage':
                  event_body = json.loads(event['body'])
                  session_id = event_body.get('sessionId', str(uuid.uuid1()))
                  input_text = event_body['inputText']

                  # Invoke the agent API
                  agent_response = bedrock_agent_runtime_client.invoke_agent(
                      inputText=input_text,
                      agentId=insureassist_agentid,
                      agentAliasId='TSTALIASID',
                      sessionId=session_id,
                      enableTrace=False,
                      endSession=False
                  )

                  # Process and stream the agent response
                  try:
                      for event in agent_response['completion']:
                          if 'chunk' in event:
                              data = event['chunk']['bytes']
                              agent_answer = data.decode('utf8')
                              message = json.dumps({
                                  'type': 'bot_response',
                                  'data': agent_answer,
                                  'sessionId': session_id
                              })
                              try:
                                  apig_management_client.post_to_connection(ConnectionId=connection_id, Data=message)
                              except apig_management_client.exceptions.GoneException:
                                  logger.info(f"Connection {connection_id} is gone.")
                          elif 'trace' in event:
                              logger.info(json.dumps(event['trace'], indent=2))
                          else:
                              raise Exception("Unexpected event.", event)
                      return {'statusCode': 200, 'body': 'Message sent'}
                  except Exception as e:
                      logger.error(f"An error occurred: {str(e)}")
                      return {'statusCode': 500, 'body': 'Internal Server Error'}
      Timeout: 900
      Environment:
        Variables:
          INSUREASSIST_AGENTID: !Ref InsuranceOrchestratorAgent

  # API Gateway (WebSockets)
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: InsureAssistWebSocketApi
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: '$request.body.action'

  WebSocketApiIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiForInsureAssistAgentLambdaFunction.Arn}/invocations'

  WebSocketApiConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$connect'
      AuthorizationType: NONE
      Target: !Sub 'integrations/${WebSocketApiIntegration}'

  WebSocketApiDisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$disconnect'
      AuthorizationType: NONE
      Target: !Sub 'integrations/${WebSocketApiIntegration}'

  WebSocketApiSendMessageRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: 'sendmessage'
      AuthorizationType: NONE
      Target: !Sub 'integrations/${WebSocketApiIntegration}'

  WebSocketApiDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    Properties:
      ApiId: !Ref WebSocketApi
    DependsOn: 
      - WebSocketApiIntegration
      - WebSocketApiConnectRoute
      - WebSocketApiDisconnectRoute
      - WebSocketApiSendMessageRoute

  WebSocketApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      StageName: production
      DeploymentId: !Ref WebSocketApiDeployment

  WebSocketApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt ApiForInsureAssistAgentLambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/production/*'

  InsureAssistUILambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InsureAssistUILambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !Sub "${DamageImagesBucket.Arn}"
                  - !Sub "${DamageImagesBucket.Arn}/*"

  InsureAssistUILambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: InsureAssistUILambdaFunction
      Handler: index.lambda_handler
      Runtime: python3.10
      Role: !GetAtt InsureAssistUILambdaRole.Arn
      Code:
        ZipFile: |
          import os
          import json
          import base64
          import boto3
          from botocore.exceptions import ClientError

          s3 = boto3.client('s3')

          def lambda_handler(event, context):
              print(f"Received event: {json.dumps(event)}")
              http_method = event['requestContext']['http']['method']
              domain_name = event['requestContext']['domainName']
              stage = event['requestContext']['stage']
              http_endpoint = f"https://{domain_name}/{stage}/"
              websocket_url = os.environ['WEBSOCKET_URL']
              bucket_name = os.environ['IMAGE_BUCKET_SUBMITTED_BY_UI']

              if http_method == 'GET':
                # HTML content for the index.html page
                html_content = f"""
                  <!DOCTYPE html>
                  <html lang="en">
                  <head>
                      <meta charset="UTF-8">
                      <meta name="viewport" content="width=device-width, initial-scale=1.0">
                      <title>Insure Assist Chatbot</title>
                      <style>
                          body {{ font-family: Arial, sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background-color: #f5f5f5; }}
                          #chat-container {{ width: 400px; border: 1px solid #ccc; padding: 10px; background-color: #fff; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); }}
                          #chat-messages {{ height: 300px; overflow-y: scroll; border-bottom: 1px solid #ccc; margin-bottom: 10px; }}
                          .user-message, .bot-message {{ text-align: right; margin: 10px; padding: 10px; background-color: #dcf8c6; border-radius: 10px; }}
                          .bot-message {{ text-align: left; background-color: #eee; }}
                          .typing-indicator {{ text-align: left; margin: 10px; padding: 10px; background-color: #eee; border-radius: 10px; display: flex; align-items: center; }}
                          .dot {{ height: 8px; width: 8px; margin: 0 2px; background-color: #bbb; border-radius: 50%; display: inline-block; animation: blink 1.4s infinite both; }}
                          .dot:nth-child(1) {{ animation-delay: 0s; }}
                          .dot:nth-child(2) {{ animation-delay: 0.2s; }}
                          .dot:nth-child(3) {{ animation-delay: 0.4s; }}
                          @keyframes blink {{
                              0% {{ opacity: 0.2; }}
                              20% {{ opacity: 1; }}
                              100% {{ opacity: 0.2; }}
                          }}
                          #user-input, #send-button, #upload-button {{ width: calc(100% - 22px); padding: 10px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px; }}
                          #send-button, #upload-button {{ background-color: #007bff; color: white; border: none; cursor: pointer; }}
                          #send-button:hover, #upload-button:hover {{ background-color: #0056b3; }}
                      </style>
                  </head>
                  <body>
                      <h1>Insure Assist Chatbot</h1>
                      <div id="chat-container">
                          <div id="chat-messages"></div>
                          <input type="text" id="user-input" placeholder="Type your message...">
                          <button id="send-button">Send</button>
                          <input type="file" id="image-upload" accept="image/*" style="display: none;">
                          <button id="upload-button">Upload Image</button>
                      </div>
                      <script>
                          document.addEventListener('DOMContentLoaded', function() {{
                              const ws = new WebSocket('{websocket_url}'); // Properly escaped
                              let sessionId = null;
                              ws.onopen = function() {{ console.log('Connected to WebSocket'); }};
                              ws.onclose = function() {{ console.log('Disconnected from WebSocket'); }};
                              ws.onmessage = function(event) {{
                                  const message = JSON.parse(event.data);
                                  const chatMessages = document.getElementById('chat-messages');
                                  const typingIndicator = document.querySelector('.typing-indicator');
                                  if (typingIndicator && message.type === 'bot_response') {{
                                      chatMessages.removeChild(typingIndicator);
                                  }}
                                  if (message.type === 'bot_response') {{
                                      chatMessages.innerHTML += '<div class="bot-message">' + message.data + '</div>';
                                      if (message.sessionId) {{
                                          sessionId = message.sessionId;
                                      }}
                                  }}
                              }};
                              const sendButton = document.getElementById('send-button');
                              const userInput = document.getElementById('user-input');
                              const chatMessages = document.getElementById('chat-messages');
                              const uploadButton = document.getElementById('upload-button');
                              const imageUpload = document.getElementById('image-upload');
                              
                              function showTypingIndicator() {{
                                const typingIndicator = document.createElement('div');
                                typingIndicator.className = 'typing-indicator';
                                typingIndicator.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
                                chatMessages.appendChild(typingIndicator);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                              }}

                              sendButton.addEventListener('click', function() {{
                                  const message = userInput.value;
                                  if (!message.trim()) return;
                                  chatMessages.innerHTML += '<div class="user-message">' + message + '</div>';
                                  userInput.value = '';
                                  showTypingIndicator();
                                  const payload = {{ action: 'sendmessage', inputText: message }};
                                  if (sessionId) {{
                                      payload.sessionId = sessionId;
                                  }}
                                  ws.send(JSON.stringify(payload));
                              }});

                              userInput.addEventListener('keypress', function(event) {{
                                  if (event.key === 'Enter') {{
                                      const message = userInput.value;
                                      if (!message.trim()) return;
                                      chatMessages.innerHTML += '<div class="user-message">' + message + '</div>';
                                      userInput.value = '';
                                      showTypingIndicator();
                                      const payload = {{ action: 'sendmessage', inputText: message }};
                                      if (sessionId) {{
                                          payload.sessionId = sessionId;
                                      }}
                                      ws.send(JSON.stringify(payload));
                                  }}
                              }});
              
                              uploadButton.addEventListener('click', function() {{
                                  imageUpload.click();
                              }});
                              imageUpload.addEventListener('change', function(event) {{
                                  const file = event.target.files[0];
                                  if (!file) return;
                                  const reader = new FileReader();
                                  reader.onload = function(e) {{
                                      const base64 = e.target.result.split(',')[1];
                                      const response = fetch('{http_endpoint}', {{
                                          method: 'POST',
                                          headers: {{ 'Content-Type': 'application/json' }},
                                          body: JSON.stringify({{ image: base64 }})
                                      }});
                                      response.then((response) => response.json()).then((data) => {{
                                          const imageUrl = data.imageUrl;
                                          sendImageMessage(imageUrl);
                                      }});
                                  }};
                                  reader.readAsDataURL(file);
                              }});

                              function sendImageMessage(imageUrl) {{
                                  chatMessages.innerHTML += '<div class="user-message">Image has been uploaded</div>';
                                  showTypingIndicator();
                                  const payload = {{ action: 'sendmessage', inputText: imageUrl }};
                                  if (sessionId) {{
                                      payload.sessionId = sessionId;
                                  }} 
                                  ws.send(JSON.stringify(payload));
                              }};

                          }});
                      </script>
                  </body>
                  </html>
                  """
                return {
                    'statusCode': 200,
                    'headers': {
                        'Content-Type': 'text/html',
                    },
                    'body': html_content
                }

              elif http_method == 'POST':
                  try:
                      body = json.loads(event['body'])
                      image_data = body.get('image')
                      if not image_data:
                          return {
                              'statusCode': 400,
                              'body': json.dumps({'message': 'Image data not provided'})
                          }

                      image_data = base64.b64decode(image_data)
                      image_key = f"images/{context.aws_request_id}.png"

                      s3.put_object(Bucket=bucket_name, Key=image_key, Body=image_data, ContentType='image/png')

                      image_url = f"{image_key}"

                      return {
                          'statusCode': 200,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*'
                          },
                          'body': json.dumps({'imageUrl': image_url})
                      }

                  except ClientError as e:
                      print(e)
                      return {
                          'statusCode': 500,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*'
                          },
                          'body': json.dumps({'message': 'Error uploading image to S3'})
                      }
                  except Exception as e:
                      print(e)
                      return {
                          'statusCode': 500,
                          'body': json.dumps({'message': 'Internal server error'})
                      }

              else:
                  return {
                      'statusCode': 405,
                      'body': json.dumps({'message': 'Method not allowed'})
                  }
      Timeout: 900
      Environment:
        Variables:
          IMAGE_BUCKET_SUBMITTED_BY_UI: !Ref DamageImagesBucket
          WEBSOCKET_URL: !Sub "wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/production/"

  # API Gateway for UI code (HTTP)
  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: InsureAssistHttpApi
      ProtocolType: HTTP

  HttpApiIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt InsureAssistUILambdaFunction.Arn
      PayloadFormatVersion: '2.0'

  HttpApiRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: 'ANY /{proxy+}'
      Target: !Sub 'integrations/${HttpApiIntegration}'

  HttpApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt InsureAssistUILambdaFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/production/*'

  HttpApiDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    Properties:
      ApiId: !Ref HttpApi
    DependsOn:
      - HttpApiRoute

  HttpApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref HttpApi
      StageName: production
      DeploymentId: !Ref HttpApiDeployment


Outputs:
  ImageBucketName:
    Description: Name of the S3 bucket for damage images
    Value: !Ref DamageImagesBucket

  PolicyDocumentsBucketName:
    Description: Name of the S3 bucket for policy documents
    Value: !Ref PolicyDocsBucket

  PolicyDocumentsKnowledgeBaseId:
    Value: !Ref BedrockKnowledgeBase
    Description: The ID of the created knowledge base.

  OpenSearchCollectionArn:
    Value: !GetAtt OpenSearchServerlessCollection.Arn
    Description: The ARN of the created OpenSearch Serverless collection.

  BedrockKnowledgeBaseRoleArn:
    Value: !GetAtt BedrockKnowledgeBaseRole.Arn
    Description: The ARN of the IAM role used by the Bedrock Knowledge Base.

  CreateIndexLambdaExecutionRoleArn:
    Value: !GetAtt CreateIndexLambdaExecutionRole.Arn
    Description: The ARN of the IAM role used by the CreateIndex Lambda function.
  
  ClaimsAdjustersQueueName:
    Value: !GetAtt ClaimsAdjustersQueue.QueueName
    Description: Name of the Claims Adjuster SQS Queue

  ClaimsAdjustersQueueUrl:
    Value: !Ref ClaimsAdjustersQueue  
    Description: URL of the Claims Adjuster SQS Queue

  InsureAssistAgentID:
    Value: !Ref InsuranceOrchestratorAgent
    Description: ID of the Insure Assist Bedrock Agent  

  PolicyAgentID:
    Value: !Ref PolicyAgent
    Description: ID of the Policy Bedrock Agent  
  
  DamageAnalysisAgentID:
    Value: !Ref DamageAnalysisAgent
    Description: ID of the Damage Analysis Agent 

  HTTPApiEndpoint:
    Description: "Endpoint URL for HTTP API Gateway"
    Value: !Sub "https://${HttpApi}.execute-api.${AWS::Region}.amazonaws.com/production/"

  WebSocketApiEndpoint:
    Description: "Endpoint URL for WebSocket API Gateway"
    Value: !Sub "wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/production/"






